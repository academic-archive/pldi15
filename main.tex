% Some notes:
%  1) Use Appel's SHA-256 implementation as an example
%



\documentclass[10pt]{article}
\usepackage{fullpage}

\usepackage[numbers]{natbib}

\usepackage[utf8]{inputenc} %for utf8 input
\usepackage{amssymb} %for shift symbol
\usepackage{amsmath}
\usepackage{listings} %for code
\usepackage{mathpartir} %for typing rules
\usepackage{microtype} %better micro typing
\usepackage{stmaryrd} %for llbracket
\usepackage{mathabx} % for boxes
\usepackage{graphicx} %to include png images
\usepackage{xcolor} %for colors
\usepackage{url}
\usepackage{enumitem}

%----------------------------------------------------

\usepackage{prettyref}
\newcommand{\pref}[1]{\prettyref{#1}}
\newcommand{\Pref}[1]{\prettyref{#1} \vpageref[]{#1}}
\newcommand{\ppref}[1]{\vpageref[]{#1}}
\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{cha}{Challenge~\ref{#1}}
\newrefformat{compiler}{Point~\ref{#1} of \pref{thm:compiler}}

%----------------------------------------------------

\usepackage{amsthm}
\theoremstyle{newstyle}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}

%----------------------------------------------------

\input{definitions}

\title{Automatic Amortized Analysis for Imperative Code}
\date{}
\author{}


\begin{document}
\maketitle

\section{Decreasing to zero}

We start with a programming language with loops counting
downwards to 0.  Statements and expressions are defined
below.  Assignments of complex expressions can be simulated
by sequencing assignments of simple expressions.
%
\begin{mathpar}

S := \code{skip}
\mid \code{assert}(\Gamma)
\mid x \gets E
\mid \code{while}(0 < x)~S
\mid \code{if}(?)~S~\code{else}~S
\mid S;S

\and

E := x + y \mid x - y % \mid y
\end{mathpar}
%
We define a deductive system to derive judgements of the
form $\Gamma; Q \vdash S \dashv Q'; \Gamma'$.  The semantics
of this judgement are defined below in the soundness section.

\begin{mathpar}

\Rule{Skip}
{}
{ \Gamma; Q + M_s \vdash \code{skip} \dashv Q; \Gamma }

\and \Rule{Assert}
{}
{ \Gamma; Q + M_a \vdash \code{assert}(\Delta) \dashv Q; \Gamma, \Delta }

% \\ \Rule{AssignP}
% { \Gamma \models \Gamma'[x/x+y] }
% {\Gamma; Q + M_s + y\cdot q_x \vdash x \gets x + y \dashv Q; \Gamma'}

% \and\Rule{AssignM}
% {  \Gamma \models \Gamma'[x/x-y]
% \\ \Gamma \models c \le y \le x
% }
% { \Gamma; Q + M_s \vdash x \gets x - y \dashv c \cdot q_x + V; \Gamma' }

\\ \Rule{While}
{ \Gamma, 0 < x ; Q - M_w^1 \vdash S \dashv M_w^2 + Q; \Gamma }
{ \Gamma; Q \vdash \code{while}(0 < x)~S \dashv Q - M_w^3; \Gamma, x \le 0 }

\and\Rule{Seq}
{  \Gamma; Q - M_s^1 \vdash S_1 \dashv Q'; \Gamma'
\\ \Gamma'; Q' - M_s^2 \vdash S_2 \dashv Q''; \Gamma''
}
{ \Gamma; Q \vdash S_1;S_2 \dashv Q''; \Gamma'' }

\end{mathpar}

\section{Decreasing differences}
The second iteration is a system more symmetric where the potentials
are linear functions in differences of variables.  From now on $k$
denotes a non-negative constant.
$$
S := \code{while}(k < x - y)~S \mid \dots
$$
%
In the rules below we take as convention that $q_{x}$ for a variable
$x$ is in fact $q_{x0}$ where 0 is a special variable fixed to zero
in all contraint contexts.

\begin{mathpar}

\Rule{AssignOpK}
{  \Gamma \models \Gamma'[x/x \pm y]
\\ \Gamma \models |y| = k
\\ \mathcal U = \left\{ u \mid \Gamma \models x \pm y \in \inter x u \right\}
\\ \textstyle q'_y = q_y
      + \sum_{u \in \mathcal U} p_{xu}
      - \sum_{v \not\in \mathcal U} q_{xv}
\\ q_{xu} = p_{xu} + r_{xu}
}
{ \textstyle
  \Gamma; Q + M_s
  \vdash x \gets x \pm y \dashv
  \sum_u k \cdot r_{xu} + Q'; \Gamma'
  % q_x is not omitted, v_{x} is in fact a shorthand for
  % v_{x0} where 0 is a variable equal to 0.
}

\and \Rule{AssignOp}
{  \Gamma \models \Gamma'[x/x \pm y]
\\ \mathcal U = \left\{ u \mid \Gamma \models x \pm y \in \inter x u \right\}
\\ \textstyle q'_y = q_y
      + \sum_{u \in \mathcal U} q_{xu}
      - \sum_{v \not\in \mathcal U} q_{xv}
}
{ \textstyle
  \Gamma; Q + M_s \vdash x \gets x \pm y \dashv Q'; \Gamma'
}

\\ \mbox{(The other rules are unchanged)}

\end{mathpar}

\section{Cost aware semantics}

This big step semantics is parameterized by a metric that sets
the cost of each program operation.  Non-deterministically,
the rule {\sc S:Abort} can be called to interrupt a computation.
It has the same effect as raising an exception.  We symbolize a
frozen computation with the notation $\circ$.  In the rules, $X$
stands for either $\circ$ or $H$.

\begin{mathpar}

\Rule{S:Abort}
{ }
{ (H, S) \Downarrow_0 \circ }

\and \Rule{S:Skip}
{ }
{ (H, \code{skip}) \Downarrow_{M_s} H }

\and \Rule{S:Assign}
{ }
{ (H, x \gets e) \Downarrow_{M_s} H[x \mapsto \llbracket e \rrbracket_H] }

\and \Rule{S:Assert}
{ H \models \Gamma }
{ (H, \code{assert}(\Gamma)) \Downarrow_{M_a} H }

\and \Rule{S:WhileStop}
{ \neg (k < \llbracket x - y \rrbracket_H) }
{ (H, \code{while}(k < x - y)~S) \Downarrow_{M_w^3} H }

\and \Rule{S:WhileStep}
{  k < \llbracket x - y \rrbracket_H
\\ (H, S) \Downarrow_{(q_1, q'_1)} H'
\\ (H', \code{while}(k < x - y)~S) \Downarrow_{(q_2, q'_2)} X
}
{ (H, \code{while}(k < x - y)~S) \Downarrow_{M_w^1 \cdot (q_1, q'_1) \cdot M_w^2 \cdot (q_2, q'_2)} X }

\and \Rule{S:WhileStepAbort}
{  k < \llbracket x - y \rrbracket_H
\\ (H, S) \Downarrow_{(q_1, q'_1)} \circ
}
{ (H, \code{while}(k < x - y)~S) \Downarrow_{M_w^1 \cdot (q_1, q'_1) } \circ }

\and \Rule{S:If}
{  (H, S_i) \Downarrow_{(q, q')} X
\\ i \in \{1, 2\}
}
{ (H, \code{if}(?)~S_1~\code{else}~S_2) \Downarrow_{M_c^i \cdot (q, q')} X }

\and \Rule{S:Seq}
{  (H, S_1) \Downarrow_{(q_1, q'_1)} H'
\\ (H', S_2) \Downarrow_{(q_2, q'_2)} X
}
{ (H, S_1; S_2) \Downarrow_{M_s^1 \cdot (q_1, q'_1) \cdot M_s^2 \cdot (q_2, q'_2)} X }

\and \Rule{S:SeqAbort}
{ (H, S_1) \Downarrow_{(q,q')} \circ }
{ (H, S_1; S_2) \Downarrow_{(q,q')} \circ }

\end{mathpar}

\section{Soundness theorem}

\begin{theorem}[Terminating case]
For any $S$, $H$, $H'$, $q$, $q'$, $\Gamma$, $\Gamma'$, $Q$ and $Q'$ such
that $\Gamma; Q \vdash S \dashv Q'; \Gamma'$ and $H \models \Gamma$ and
$(H,s) \Downarrow_{(q,q')} H'$, we have
$H' \models \Gamma'$ and
$q \le \Phi_H(Q)$ and
$\Phi_H(Q) - \Phi_{H'}(Q') \ge q - q'$.
\end{theorem}

\begin{proof} By induction on the big step semantics.

\begin{itemize}

\item Case {\sc S:Skip}.
  We have $(H, \code{skip}) \Downarrow_{M_s} H$.
  By assumption, $H \models \Gamma$. \\
  Since $\Phi_H(Q + M_s) = \Phi_H(Q) + M_s$,
  \begin{itemize}[topsep=0pt]
  \item
    if $M_s \ge 0$ we have,
      $M_s \le \Phi_H(Q + M_s)$ and
      $\Phi_H(Q + M_s) - \Phi_H(Q) \ge M_s - 0$;
  \item
    if $M_s < 0$ we have,
      $0 \le \Phi_H(Q + M_s)$ and
      $\Phi_H(Q + M_s) - \Phi_H(Q) \ge 0 - (-M_s)$.
  \end{itemize}

\item Case {\sc S:Seq}.
  By transitivity and induction hypothesis, it is
  easy to get $H'' \models \Gamma''$.  Now we prove
  the quantitative part of the theorem.  We have
  $(q, q') = M_s^1 \cdot (q_1, q'_1) \cdot M_s^2 \cdot (q_2, q'_2)$.
  We assume $\forall i \in \{1, 2\},~M_s^i \ge 0$, the other cases
  are similar.
  \begin{itemize}[topsep=0pt]
  \item
    The first case is when $q'_1 > M_s^2 + q_2$ then $q = M_s^1 + q_1$
    and since $q_1 \le \Phi_H(Q - M_s^1)$ (by induction) we have
    $q \le \Phi_H(Q)$.
  \item
    The second case is when $q'_1 \le M_s^2 + q_2$ then $q = M_s^1 + q_1 + M_s^2 + q_2 - q'_1$. \\
    Since $\Phi_H(Q - M_s^1) - \Phi_{H'}(Q') \ge q_1 - q'_1$
    and $q_2 \le \Phi_{H'}(Q' - M_s^2)$ we have:
    \begin{align*}
    q &\le M_s^1 + \Phi_H(Q - M_s^1) - \Phi_{H'}(Q') + M_s^2 + q_2 \\
      &= \Phi_H(Q) + (q_2 - \Phi_{H'}(Q' - M_s^2)) \le \Phi_H(Q).
   \end{align*}
  \end{itemize}
  We obtain $\Phi_H(Q) - \Phi_{H''}(Q'') \ge q - q'$ by simply chaining
  the two induction hypothesis and using the fact that $q - q' =
  (q_1 + M_s^1 - q'_1) + (q_2 + M_s^2 - q'_2)$.

\item Case {\sc S:WhileStop}.
  This proof goes just like in the {\sc S:Skip} case.

\item Case {\sc S:WhileStep}.
  Here again we assume $\forall i \in \{1, 2, 3\},~M_w^i \ge 0$.
  \begin{itemize}[topsep=0pt]
  \item
    If $q'_1 > M_w^2 + q_2$ then $q = M_w^1 + q_1$ and by induction
    we get $q_1 \le \Phi_H(Q - M_w^1)$, so $q \le \Phi_H(Q)$.
  \item
    If $q'_1 \le M_w^2 + q_2$ then $q = M_w^1 + q_1 + M_w^2 + q_2 - q'_1$.
    And we proceed like in the sequence case.
  \end{itemize}
  We obtain $\Phi_H(Q) - \Phi_{H''}(Q - M_w^3) \ge q - q'$ using the identity
  $q - q' = (M_w^1 + M_w^2 + q_1 - q'_1) + q_2 - q'_2$ and the two
  induction hypothesis
  \begin{itemize}[topsep=0pt]
  \item $\Phi_H(Q - M_w^1) - \Phi_{H'}(Q + M_w^2) \ge q_1 - q'_1$ and
  \item $\Phi_{H'}(Q) - \Phi_{H''}(Q - M_w^3) \ge q_2 - q'_2.$
  \end{itemize}

\end{itemize}
\end{proof}

\section{Polynomial Potential}

\paragraph{Index Sets}

Let $V$ be a set of variables.  An \emph{index} $I \in \ind(V)$ is a
family that maps two-element sets of variables to natural numbers,
that is,
$$
I = (i_{\{x,y\}})_{\{x,y\} \subseteq V} \; .
$$
%
We identify a family $I$ with the set $\{ (\{x,y\},i_{\{x,y\}})
\mid \{x,y\} \subseteq V\}$.

Let $\ind(V)$ denote the set of all such indices.  We write $\ind$
instead of $\ind(V)$ if the set of variables $V$ is fixed or obvious
from the context.
%
We assume that allways $0 \in V$ and sometimes write $i_x$ instead of $i_{\{x,0\}}$.

The \emph{degree} $\deg(I)$ of an index $I = (i_{\{x,y\}})_{\{x,y\}
  \subseteq V}$ is defined as
$$
\deg(I) = \sum_{\{x,y\} \in V} i_{\{x,y\}} \;.
$$
We define $\ind_k(V) = \{ I \mid I \in \ind(V) \text{ and } \deg(i) \leq k
\}$ to be the set of indices of degree at most $k$.

\paragraph{Resource Polynomials}

Let $V$ be a set of variables.  An index $I \in \ind(V)$ denotes a
\emph{base polynomial} $P_I : \states \to \N$ for $V$ that maps a
program state $H$ to product of binomial coefficients (a natural
number).  We define
$$
P_I(H) = \prod_{{\{x,y\}} \subseteq V} \binom {|H(x){-}H(y)|} {i_{\{x,y\}}} \; .
$$
%
A \emph{resource polynomial} $R$ for the variable set $V$ is a
non-negative linear combination of the base polynomials for $V$.

\paragraph{Potential Annotations}

A \emph{potential annotation} for the variable set $V$ is a family
$$Q = (q_I)_{I \in \ind(V)}$$ 
of non-negative rational numbers.  Such an annotation denotes the
resource polynomial $R_Q$ that is defined by
$$
R_Q(H) = \sum_{I \in \ind(V)} q_I \cdot P_I(H) \; .
$$
%
We say that the potential annotation $Q$ is of degree $k$ if $q_I = 0$
for $I \in \ind(V)$ with $\deg(I) > k$.

\paragraph{Additive Shifts}

Let $Q$ be a potential annotation for a variable set $V$ and let
$\{x,y\} \subseteq V$ be a two-element variable set.  The
\emph{additive shift} with respect to $\{x,y\}$ is a potential
annotation $\shift_{\{x,y\}}(Q) = (q'_I)_{I \in \ind(V)} $ for $V$
that is defined through
$$
q'_I = q_I + q_{I^{\{x,y\}{+}1}} \; .
$$
For an index $I = (i_{\{x,y\}})_{\{x,y\} \subseteq V}$ we use the
notation $I^{\{x,y\}{+}k}$ to denote the index
$(i'_{\{x,y\}})_{\{x,y\} \subseteq V}$ such that
$$
i'_{\{t,u\}} = \left\{
  \begin{array}{ll}
    i_{\{t,u\}} + k  & \text{if } \{t,u\} = \{x,y\} \\
    i_{\{t,u\}} & \text{otherwise}
  \end{array}
\right.
\;.
$$
%
The additive shift for natural numbers reflects the identity 
\begin{equation}
\label{eq:shift}
\sum_{0 {\leq} i \leq {k}} q_i \binom{n+1}{i} = \sum_{0 {\leq} i \leq {k}} (q_i{+}q_{i+1}) \binom{n}{i}
\end{equation}
where $q_{k+1} = 0$.  It is used in the effect system if the
difference $n+1$ between two variables $x,y$ decreases by one.

\begin{lemma} Let $V$ be a set of variables with $x,y \in V$ and let
  $H$ be a program state. Let $|H'(t) {-} H'(u)| = |H(t) {-} H(u)|$
  for $\{t,u\} \neq \{x,y\}$ and let $|H'(x) {-} H'(y)| = |H(x) {-}
  H(y)| - 1$.
  %
  If $Q' = \shift_{\{x,y\}}(Q)$ then $R_Q(H) = R_{Q'}(H')$.
\end{lemma}

We now study the effect of multiple simultaneous shifts.  Let $Q$ be a
resource annotation for a variable set $V$ and let $U_1,\ldots,U_n
\subseteq V$ with $|U_i| = 2$ for all $i$ and $U_i \neq U_j$ for $i
\neq j$ be pairwise distinct two-element variable sets.  The
simulations additive shift $\shift_{U_1,\ldots,U_n}(Q)$ of $Q$ with
respect to $U_1,\ldots,U_n$ is defined by
$$
\shift_{U_1,\ldots,U_n}(Q) = \shift_{U_1}( \cdots \shift_{U_n}(Q) \cdots ) \; .
$$
%
\begin{proposition}
  Let $V$ be a set of variables and let $U_1,\ldots,U_n$ be pairwise
  distinct two-element variable sets.  Let $|H'(x) {-} H'(y)| = |H(x)
  {-} H(y)|$ for $\{x,y\} \not\in \{U_1,\ldots,U_n\}$ and let $|H'(x)
  {-} H'(y)| = |H(x) {-} H(y)| - 1$ for $\{x,y\} \in
  \{U_1,\ldots,U_n\}$.
  %
  If $Q' = \shift_{\{U_1,\ldots,U_n\}}(Q)$ then $R_Q(H) = R_{Q'}(H')$.
\end{proposition}
%
As shown by the following lemma, the order in which the shifts for the
individual $U_i$ are applied is insignificant.
%
\begin{lemma}
  Let $\sigma : \{1,\ldots,n\} \to \{1,\ldots,n\}$ be a
  permutation. Then $\shift_{U_1,\ldots,U_n}(Q) =
  \shift_{U_{\sigma(1)},\ldots,U_{\sigma(n)}}(Q)$.
\end{lemma}
%
For reasons of efficiency in the constraint generation, we give a more
direct formula for the simultaneous shift.  Let $I \in \ind(V)$ and
let $U_1,\ldots,U_n$ be pairwise distinct two-element variable sets.
We define the index $I^{U_1,\ldots,U_n + k}$ as the family $(i'_{\{x,y\}})_{\{x,y\} \subseteq V}$ such that
$$
i'_{\{t,u\}} = \left\{
  \begin{array}{ll}
    i_{\{t,u\}} + k  & \text{if } \{t,u\} \in \{U_1,\ldots,U_n\} \\
    i_{\{t,u\}} & \text{otherwise}
  \end{array}
\right.  \;.
$$

%
\begin{lemma}
  Let $V$ be a variable set and let $U_1,\ldots,U_n$ be pairwise
  distinct two-element variable sets.
  %
  Let $Q = (q_I)_{I \in \ind(V)}$ be a resource annotation for
  $V$ and let $ Q' = (q'_I)_{I \in \ind(V)}$ where
  $$
  q'_I = \sum_{\{j_1,\ldots,j_m\} \subseteq \{1,\ldots,n\} } q_{I^{U_{j_1},\ldots,U_{j_m}+1}} \; .
  $$
  Then $Q' = \shift_{U_1,\ldots,U_n}(Q)$.
\end{lemma}




%%
% Note: Later we need to shift in many directions at once like 
%   Q' = shift_{x,y} (shift_{x,u} (Q))
% To do: Give a combined formula for that (concise constraint system).
%%





\end{document}
