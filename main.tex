\documentclass[10pt]{article}
\usepackage{fullpage}

\usepackage[numbers]{natbib}

\usepackage[utf8]{inputenc} %for utf8 input
\usepackage{amssymb} %for shift symbol
\usepackage{amsmath}
\usepackage{listings} %for code
\usepackage{mathpartir} %for typing rules
\usepackage{microtype} %better micro typing
\usepackage{stmaryrd} %for llbracket
\usepackage{mathabx} % for boxes
\usepackage{graphicx} %to include png images
\usepackage{xcolor} %for colors
\usepackage{url}

%----------------------------------------------------

\usepackage{prettyref}
\newcommand{\pref}[1]{\prettyref{#1}}
\newcommand{\Pref}[1]{\prettyref{#1} \vpageref[]{#1}}
\newcommand{\ppref}[1]{\vpageref[]{#1}}
\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{cha}{Challenge~\ref{#1}}
\newrefformat{compiler}{Point~\ref{#1} of \pref{thm:compiler}}

%----------------------------------------------------

\usepackage{amsthm}
\theoremstyle{newstyle}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}

%----------------------------------------------------

\input{definitions}

\title{Automatic Amortized Analysis for Imperative Code}
\date{}
\author{}


\begin{document}
\maketitle

\section{Decreasing to zero}

We start with a programming language with loops counting
downwards to 0.  Statements and expressions are defined
below.  Assignments of complex expressions can be simulated
by sequencing assignments of simple expressions.
%
\begin{mathpar}
S := \code{skip}
\mid \code{assert}(\Gamma)
\mid x \gets E
\mid \code{while}(0 < x)~S
\mid \code{if}(?)~S~\code{else}~S
\mid S;S

\and

E := x + y \mid x - y % \mid y
\end{mathpar}
%
We define a deductive system to derive judgements of the
form $\Gamma; Q \vdash S \dashv Q'; \Gamma'$ with the following
intended semantics
$$
\forall H\, H'\, S\, n,
    ( H \models \Gamma \land
      (H, S) \Downarrow_n H'
    ) \Rightarrow
    ( H' \models \Gamma' \land
      \Phi_{H}(Q) \ge n + \Phi_{H'}(Q')
    ).
$$

\begin{mathpar}

\Rule{Skip}
{}
{ \Gamma; Q \vdash \code{skip} \dashv Q; \Gamma }

\and \Rule{Assert}
{}
{ \Gamma; Q \vdash \code{assert}(\Delta) \dashv Q; \Gamma, \Delta }

\\ \Rule{AssignP}
{ \Gamma \models \Gamma'[x/x+y] }
{\Gamma; Q + y\cdot q_x \vdash x \gets x + y \dashv Q; \Gamma'}

\and\Rule{AssignM}
{  \Gamma \models \Gamma'[x/x-y]
\\ \Gamma \models c \le y \le x
}
{ \Gamma; Q \vdash x \gets x - y \dashv c \cdot q_x + V; \Gamma' }

\\ \Rule{While}
{ \Gamma, 0 < x ; Q - M_w \vdash S \dashv Q; \Gamma }
{ \Gamma; Q \vdash \code{while}(0 < x)~S \dashv Q; \Gamma, x \le 0 }

\and\Rule{Seq}
{  \Gamma; Q \vdash S_1 \dashv Q'; \Gamma'
\\ \Gamma'; Q' \vdash S_2 \dashv Q''; \Gamma''
}
{ \Gamma; Q \vdash S_1;S_2 \dashv Q''; \Gamma'' }

\end{mathpar}

\section{Decreasing differences}
The second iteration is a system more symmetric where the potentials
are linear functions in differences of variables.  From now on $k$
denotes a non-negative constant.
$$
S := \code{while}(k < x - y)~S \mid \dots
$$

\begin{mathpar}

\Rule{AssignOpK}
{  \Gamma \models \Gamma'[x/x \pm y], y = k
\\ \Gamma \models x \pm y \in [x, u]
\\ \textstyle q'_y = q_y + \sum_u q^1_{xu} - \sum_v q_{xv}
\\ q_{xu} = q^1_{xu} + q^2_{xu}
}
{ \textstyle
  \Gamma; Q \vdash x \gets x \pm y \dashv \sum_u k \cdot q^2_{xu} + Q'; \Gamma'
}

\and \Rule{AssignOp}
{  \Gamma \models \Gamma'[x/x \pm y]
\\ \Gamma \models x \pm y \in [x, u]
\\ \textstyle q'_y = q_y + \sum_u q_{xu} - \sum_v q_{xv}
}
{ \textstyle
  \Gamma; Q \vdash x \gets x \pm y \dashv Q'; \Gamma'
}

\\ \mbox{(The other rules are unchanged)}

\end{mathpar}


\end{document}
