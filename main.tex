\documentclass[10pt]{article}
\usepackage{fullpage}

\usepackage[numbers]{natbib}

\usepackage[utf8]{inputenc} %for utf8 input
\usepackage{amssymb} %for shift symbol
\usepackage{amsmath}
\usepackage{listings} %for code
\usepackage{mathpartir} %for typing rules
\usepackage{microtype} %better micro typing
\usepackage{stmaryrd} %for llbracket
\usepackage{mathabx} % for boxes
\usepackage{graphicx} %to include png images
\usepackage{xcolor} %for colors
\usepackage{url}

%----------------------------------------------------

\usepackage{prettyref}
\newcommand{\pref}[1]{\prettyref{#1}}
\newcommand{\Pref}[1]{\prettyref{#1} \vpageref[]{#1}}
\newcommand{\ppref}[1]{\vpageref[]{#1}}
\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{cha}{Challenge~\ref{#1}}
\newrefformat{compiler}{Point~\ref{#1} of \pref{thm:compiler}}

%----------------------------------------------------

\usepackage{amsthm}
\theoremstyle{newstyle}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}

%----------------------------------------------------

\input{definitions}

\title{Automatic Amortized Analysis for Imperative Code}
\date{}
\author{}


\begin{document}
\maketitle

\section{Decreasing to zero}

We start with a programming language with loops counting
downwards to 0.  Statements and expressions are defined
below.  Assignments of complex expressions can be simulated
by sequencing assignments of simple expressions.
%
\begin{mathpar}

S := \code{skip}
\mid \code{assert}(\Gamma)
\mid x \gets E
\mid \code{while}(0 < x)~S
\mid \code{if}(?)~S~\code{else}~S
\mid S;S

\and

E := x + y \mid x - y % \mid y
\end{mathpar}
%
We define a deductive system to derive judgements of the
form $\Gamma; Q \vdash S \dashv Q'; \Gamma'$ with the following
intended semantics
$$
\forall H\, H'\, S\, n,
    ( H \models \Gamma \land
      (H, S) \Downarrow_n H'
    ) \Rightarrow
    ( H' \models \Gamma' \land
      \Phi_{H}(Q) \ge n + \Phi_{H'}(Q')
    ).
$$

\begin{mathpar}

\Rule{Skip}
{}
{ \Gamma; Q \vdash \code{skip} \dashv Q; \Gamma }

\and \Rule{Assert}
{}
{ \Gamma; Q \vdash \code{assert}(\Delta) \dashv Q; \Gamma, \Delta }

\\ \Rule{AssignP}
{ \Gamma \models \Gamma'[x/x+y] }
{\Gamma; Q + y\cdot q_x \vdash x \gets x + y \dashv Q; \Gamma'}

\and\Rule{AssignM}
{  \Gamma \models \Gamma'[x/x-y]
\\ \Gamma \models c \le y \le x
}
{ \Gamma; Q \vdash x \gets x - y \dashv c \cdot q_x + V; \Gamma' }

\\ \Rule{While}
{ \Gamma, 0 < x ; Q - M_w \vdash S \dashv Q; \Gamma }
{ \Gamma; Q \vdash \code{while}(0 < x)~S \dashv Q; \Gamma, x \le 0 }

\and\Rule{Seq}
{  \Gamma; Q \vdash S_1 \dashv Q'; \Gamma'
\\ \Gamma'; Q' \vdash S_2 \dashv Q''; \Gamma''
}
{ \Gamma; Q \vdash S_1;S_2 \dashv Q''; \Gamma'' }

\end{mathpar}

\section{Decreasing differences}
The second iteration is a system more symmetric where the potentials
are linear functions in differences of variables.  From now on $k$
denotes a non-negative constant.
$$
S := \code{while}(k < x - y)~S \mid \dots
$$
%
In the rules below we take as convention that $q_{x}$ for a variable
$x$ is in fact $q_{x0}$ where 0 is a special variable fixed to zero
in all contraint contexts.

\begin{mathpar}

\Rule{AssignOpK}
{  \Gamma \models \Gamma'[x/x \pm y]
\\ \Gamma \models |y| = k
\\ \mathcal U = \left\{ u \mid \Gamma \models x \pm y \in \inter x u \right\}
\\ \textstyle q'_y = q_y
      + \sum_{u \in \mathcal U} p_{xu}
      - \sum_{v \not\in \mathcal U} q_{xv}
\\ q_{xu} = p_{xu} + r_{xu}
}
{ \textstyle
  \Gamma; Q
  \vdash x \gets x \pm y \dashv
  \sum_u k \cdot r_{xu} + Q'; \Gamma'
  % q_x is not omitted, v_{x} is in fact a shorthand for
  % v_{x0} where 0 is a variable equal to 0.
}

\and \Rule{AssignOp}
{  \Gamma \models \Gamma'[x/x \pm y]
\\ \mathcal U = \left\{ u \mid \Gamma \models x \pm y \in \inter x u \right\}
\\ \textstyle q'_y = q_y
      + \sum_{u \in \mathcal U} q_{xu}
      - \sum_{v \not\in \mathcal U} q_{xv}
}
{ \textstyle
  \Gamma; Q \vdash x \gets x \pm y \dashv Q'; \Gamma'
}

\\ \mbox{(The other rules are unchanged)}

\end{mathpar}

\section{Cost aware semantics}

This big step semantics counts the number of iterations of
while loops in a program as it executes it.  Non-deterministically,
the {\sc S:Bubble} rule can be called to interrupt a computation.
It has the same effect as raising an exception.  We symbolize an
immutable heap with the notation $\circ H$, this kind of heap just
bubbles up through the semantics. In the rules, $X$ stands for
either $H$ or $\circ H$ for some $H$.

\begin{mathpar}

\Rule{S:Bubble}
{}
{ (H, S) \Downarrow_0 \circ H }

\and \Rule{S:Skip}
{}
{ (H, \code{skip}) \Downarrow_0 H }

\and \Rule{S:Assign}
{}
{ (H, x \gets e) \Downarrow_0 H[x \gets \llbracket e \rrbracket_H] }

\and \Rule{S:Assert}
{ \Gamma \models H }
{ (H, \code{assert}(\Gamma)) \Downarrow_0 H }

\and \Rule{S:WhileStop}
{ \neg (k < \llbracket x - y \rrbracket_H) }
{ (H, \code{while}(k < x - y)~S) \Downarrow_0 H }

\and \Rule{S:WhileStep}
{  k < \llbracket x - y \rrbracket_H
\\ (H, S; \code{while}(k < x - y)~S) \Downarrow_n X
}
{ (H, \code{while}(k < x - y)~S) \Downarrow_{n+1} X }

\and \Rule{S:If}
{  (H, S_i) \Downarrow_n X
\\ i \in \{1, 2\}
}
{ (H, \code{if}(?)~S_1~\code{else}~S_2) \Downarrow_n X }

\and \Rule{S:Seq}
{  (H, S_1) \Downarrow_{n_1} H'
\\ (H', S_2) \Downarrow_{n_2} H''
}
{ (H, S_1; S_2) \Downarrow_{n_1 + n_2} H'' }

\and \Rule{S:SeqBubble}
{ (H, S_1) \Downarrow_n \circ H' }
{ (H, S_1; S_2) \Downarrow_n \circ H' }

\end{mathpar}

\end{document}
