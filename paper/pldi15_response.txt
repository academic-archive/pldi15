Main criticisms:
  1 - Limited to linear bounds
  2 - Supported language features
  3 - Analysis of large programs

Points to address:
  1 - Describe Q:Loop



We thank the reviewers for the positive and precise evaluation. We
first comment on three main points and then respond to the remaining
points of each review individually.

+++ Supported language features

While our presentation indeed focuses on a fragment of Clight, our
analysis is implemented for idiomatic C programs. Currently, the only
language features that are not support are function pointers and local
variables (stored on the stack) that have their address
taken. However, our technique is in principle suitable to handle these
features.

Technically, we support C by using CIL to compile C to Clight prior
the analysis. This is briefly described in the 4th paragraph of page
6. There are two technical issues. First, there are operations that we
do not track in our potential functions, such as pointer arithmetic
and multiplication.  We simply set the potential of the associated
variables to zero. Second, we break up linear expressions into
sequences that can be handled by the described rules without changing
the execution cost. For example, we split

    x += y + 2;

into

    x += y;
    x += 2;  /* cost free */

where we made the second increment cost free to make the transformation
cost preserving.

Admittedly, we did not describe our support of C programs sufficiently
and will provide more details in the next version of the paper.

+++ Non-linear bounds

A unique advantage of the potential-based approach is that it allows
the automatic inference of multivariate *polynomial* bounds by using
efficient LP solving only. This technique has been described in the
paper "Multivariate Amortized Resource Analysis" at POPL'11 and the
derived bounds are so-called multivariate resource polynomials.

We designed the present analysis system with an extension to these
multivariate resource polynomials in mind.  However, we realized that
the polynomial version of the system makes the rules mathematically
quite involved while not being necessary to describe the main novel
ideas. As a result, we decided report on the extension to polynomial
bounds in a separate paper.

It is also possible to semi-automatically derive non-polynomial and
polynomial bounds using user-defined logical variables and assertions
as described in Section 6.

+++ Analysis for large programs

In general, the analysis scales well to larger programs. For example,
we performed an experiment with a new macro-benchmark. This benchmark
first decrypts a chunk of 'len' bytes using the IDEA algorithm in CFB
block mode, then computes a MD5 hash of the resulting plaintext.  We
ran three experiments:

   Run 1 - MD5 part only:  495 lines analyzed in 1.135 sec
   Run 2 - IDEA part only: 240 lines analyzed in 4.632 sec
   Run 3 - MD5 + IDEA:     735 lines analyzed in 6.721 sec

According to these tests, analyzing the sequence of the MD5 and IDEA
parts costs roughly as much as the sum of the costs for the two parts.
This quasi-linear behavior seems to be typical in practice.
Nevertheless, the runtime of our analysis grows quadratically in the
number of integer variables tracked. Right now, we track all variables
and cryptographic code is challenging because plenty of integer
variables are used for bit. Regardless, C4B runs still efficiently on
medium sized programs. To improve the efficiency further, it would be
possible to combine the analysis with program slicing and taint
analysis to identify the integer variables that influence the control
flow before the analysis.

There are still some practical issues that prevent C4B from being an
out-of-the-box tool for large existing C programs.

  1) Our analysis needs the definition of all functions used.  This
     means that if some code uses standard library function like
     'memcpy', we have to replace the library function with its source
     code.

  2) Many loops in the wild are on C strings, i.e., they have a
     termination condition like (*p != 0).  Our analysis cannot bound
     such loops because a bound would rely on a sophisticated (and
     sometimes doubtful) heap invariant.

  3) Any program that loops over a linked-list, a tree, or another
     heap data structure needs to be instrumented with logical state.

  4) Any program with super-linear complexity also needs to be
     instrumented.

+++ Point-By-Point Response


